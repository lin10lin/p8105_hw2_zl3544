---
title: "p8105_hw2_zl3544"
output: html_document
date: "2024-09-30"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
library(tidyverse)
```

## Problem 1

Using relative path to access the CSV file and clean the data:
```{r, message=FALSE}
NYC_transit_df = 
  read_csv("./data/NYC_Transit_Data.csv", na=c("NA","", ".")) %>% 
  janitor::clean_names() %>% 
  select(line:entry, vending, ada) %>% 
 mutate(
    entry = case_match(
      entry,
      "YES" ~ TRUE,
      "NO" ~ FALSE
    )
  )

```
Then see the head of the selected dataframe:
```{r}
head(NYC_transit_df)
```
In the data cleaning process above, I: Use the relative path to read the csv file, then treat "NA","", "." as missing, then select the variable that worth analyzing in this problem, and clean up variable names, finally, I convert the entry variable from character to a logical variable.

After reading, selecting and cleaning the data, the data set to analyze has 1868 rows and 19 columns. But the data isn't tidy, for the reason that different routes are considered as different variables, these columns contain value information, they can be transformed.

Caculate the distinct stations using distinct function:
```{r, message=FALSE}
distinct_stations= count(distinct(NYC_transit_df, station_name, line))
```
There are `r count(distinct(NYC_transit_df, station_name, line))` distinct stations.

Caculate the ADA compliant stations:
```{r, message=FALSE}
ada_compliant_stations= 
  NYC_transit_df %>% 
  filter(ada==TRUE) %>% 
  distinct(station_name, line) %>% 
  nrow() 
  
```
There are `r filter(NYC_transit_df, ada == "TRUE") %>% distinct(station_name, line) %>% nrow` ADA compliant stations.

Caculate the number of station entrances / exits without vending allow entrance:
```{r, message=FALSE}
no_vending_entry=
  filter(NYC_transit_df, vending=="NO") %>% 
  filter(entry=="TRUE") %>% 
  nrow()
```
Then the proportion of station entrances / exits without vending allow entrance is: `r (filter(NYC_transit_df, vending=="NO") %>% filter(entry=="TRUE") %>% nrow)/(filter(NYC_transit_df, vending=="NO") %>% nrow)`

Reformat data:
```{r}
Tidy_NYC_transit_df =
  NYC_transit_df %>% 
  mutate(
    across(route8:route11, as.character)
  ) %>% 
  pivot_longer(
    route1:route11,
    names_to="route_name",
    names_prefix="route",
    values_to="train",
    values_drop_na=TRUE
  ) 
```
Caculate distinct stations serve the A train using R:
```{r, message=FALSE}
stations_serve_A=
  Tidy_NYC_transit_df %>% 
  filter(train=="A") %>% 
  distinct(line, station_name) %>% 
  nrow() 
```
Distinct stations serve the A train is `r stations_serve_A`.

Caculate the stations that serve the A train, are ADA compliant:
```{r, message=FALSE}
stations_serve_A_ada=
  Tidy_NYC_transit_df %>% 
  filter(train=="A" & ada=="TRUE") %>% 
  distinct(line, station_name) %>% 
  nrow()
```
Among the stations that serve the A train, `r stations_serve_A_ada` are ADA compliant

Problem 2

Problem 3

import the data :
```{r}
bakers_df=
  read_csv("./data/gbb_datasets/bakers.csv", na=c("NA","",".")) %>% 
  janitor::clean_names() %>% 
  separate(baker_name, into = c("baker", "last_name"), sep = " ")
head(bakers_df)
```
```{r}
bakes_df=
  read_csv("./data/gbb_datasets/bakes.csv", na=c("NA","",".")) %>% 
  janitor::clean_names()
head(bakes_df)
```
```{r}
results_df=
  read_csv("./data/gbb_datasets/results.csv",skip=2 ,na=c("NA","",".")) %>% 
  janitor::clean_names()
head(results_df)
```
```{r}
anti_join(bakes_df, bakers_df, by = "baker", "series")
anti_join(results_df, bakers_df, by = "baker", "series")
anti_join(bakers_df, results_df, by = "baker", "series")
```
The result show that the name Joanne and Jo doesnâ€™t match, both name are from the same series, so I suppose that their are the same people, note as Jo
```{r}
results_df = 
  results_df  %>% 
  mutate(baker = ifelse(baker == "Joanne", "Jo", baker))
bakes_df = 
  bakes_df %>% 
  mutate(baker = ifelse(baker == '"Jo"', "Jo", baker))

anti_join(bakes_df, bakers_df, by = "baker", "series")
anti_join(results_df, bakers_df, by = "baker", "series")
anti_join(bakers_df, results_df, by = "baker", "series")
```
Remame Jo to the results_df and bakes_df, the dataset all match with each other.





# description 
When seeing the raw data, the baker.csv contains the full name of the baker, however, the bakes.csv and results.csv only include the first name of the baker, so I split the full name of the baker in the baker.csv data. Also, in the results.csv, the first two rows contains no useful information and lead confuse when handle with this data, so I skip the first two rows. Then I use anti_join function to see how different datasets match, 